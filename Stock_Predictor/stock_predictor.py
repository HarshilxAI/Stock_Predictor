# -*- coding: utf-8 -*-
"""Stock_Predictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1La-JDDqVgacLglmdU9wAcRnHcgoyGXCn
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

!pip install yfinance

import yfinance as yf

stocks = ["NMDC.NS", "NHPC.NS", "IOB.NS", "CASTROLIND.NS", "ASHOKLEY.NS"]

stock_data = {}

# 5 years of data from selected stocks
for stock in stocks:
    data = yf.download(stock, start="2019-01-01", end="2024-12-31")
    stock_data[stock] = data
    print(f"âœ… Data fetched for {stock} | Rows: {data.shape[0]}")

stock_data[stocks[0]].head()

import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))

for stock in stocks:
    plt.plot(stock_data[stock]['Close'], label=stock)

plt.title("Stock Price Trends (2019â€“2025)")
plt.xlabel("Date")
plt.ylabel("Closing Price (INR)")
plt.legend()
plt.grid(True)
plt.show()

from sklearn.preprocessing import MinMaxScaler
import numpy as np

stock = "NMDC.NS"
df = stock_data[stock]

close_prices = df['Close'].values.reshape(-1,1)

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(close_prices)

sequence_length = 60  # last 60 days
X = []
y = []

for i in range(sequence_length, len(scaled_data)):
    X.append(scaled_data[i-sequence_length:i, 0])
    y.append(scaled_data[i, 0])


X, y = np.array(X), np.array(y)

X = np.reshape(X, (X.shape[0], X.shape[1], 1))

train_size = int(0.8 * X.shape[0])
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

print("Training samples:", X_train.shape[0])
print("Testing samples:", X_test.shape[0])

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

model_nmdc = Sequential()

model_nmdc.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model_nmdc.add(Dropout(0.2))  # Prevent overfitting

model_nmdc.add(LSTM(units=50, return_sequences=False))
model_nmdc.add(Dropout(0.2))

model_nmdc.add(Dense(1))  # Predict next day price

model_nmdc.compile(optimizer='adam', loss='mean_squared_error')

model_nmdc.summary()

# Train NMDC model
history_nmdc = model_nmdc.fit(X_train, y_train, epochs=50, batch_size=32, validation_data=(X_test, y_test))

stock = "NHPC.NS"
df_nhpc = stock_data[stock]

close_prices_nhpc = df_nhpc['Close'].values.reshape(-1,1)

scaler_nhpc = MinMaxScaler(feature_range=(0,1))
scaled_data_nhpc = scaler_nhpc.fit_transform(close_prices_nhpc)

sequence_length = 60
X_nhpc = []
y_nhpc = []

for i in range(sequence_length, len(scaled_data_nhpc)):
    X_nhpc.append(scaled_data_nhpc[i-sequence_length:i, 0])
    y_nhpc.append(scaled_data_nhpc[i, 0])

X_nhpc, y_nhpc = np.array(X_nhpc), np.array(y_nhpc)
X_nhpc = np.reshape(X_nhpc, (X_nhpc.shape[0], X_nhpc.shape[1], 1))

train_size = int(0.8 * X_nhpc.shape[0])
X_train_nhpc, X_test_nhpc = X_nhpc[:train_size], X_nhpc[train_size:]
y_train_nhpc, y_test_nhpc = y_nhpc[:train_size], y_nhpc[train_size:]

print("NHPC - Training samples:", X_train_nhpc.shape[0])
print("NHPC - Testing samples:", X_test_nhpc.shape[0])

model_nhpc = Sequential()

model_nhpc.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_nhpc.shape[1],1)))
model_nhpc.add(Dropout(0.2))

model_nhpc.add(LSTM(units=50, return_sequences=False))
model_nhpc.add(Dropout(0.2))

model_nhpc.add(Dense(1))

model_nhpc.compile(optimizer='adam', loss='mean_squared_error')
model_nhpc.summary()

history_nhpc = model_nhpc.fit(X_train_nhpc, y_train_nhpc, epochs=50, batch_size=32, validation_data=(X_test_nhpc, y_test_nhpc))

stock = "IOB.NS"
df_iob = stock_data[stock]

close_prices_iob = df_iob['Close'].values.reshape(-1,1)

scaler_iob = MinMaxScaler(feature_range=(0,1))
scaled_data_iob = scaler_iob.fit_transform(close_prices_iob)

sequence_length = 60
X_iob = []
y_iob = []

for i in range(sequence_length, len(scaled_data_iob)):
    X_iob.append(scaled_data_iob[i-sequence_length:i, 0])
    y_iob.append(scaled_data_iob[i, 0])

X_iob, y_iob = np.array(X_iob), np.array(y_iob)
X_iob = np.reshape(X_iob, (X_iob.shape[0], X_iob.shape[1], 1))

train_size = int(0.8 * X_iob.shape[0])
X_train_iob, X_test_iob = X_iob[:train_size], X_iob[train_size:]
y_train_iob, y_test_iob = y_iob[:train_size], y_iob[train_size:]

print("IOB - Training samples:", X_train_iob.shape[0])
print("IOB - Testing samples:", X_test_iob.shape[0])

model_iob = Sequential()

model_iob.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_iob.shape[1],1)))
model_iob.add(Dropout(0.2))

model_iob.add(LSTM(units=50, return_sequences=False))
model_iob.add(Dropout(0.2))

model_iob.add(Dense(1))

model_iob.compile(optimizer='adam', loss='mean_squared_error')
model_iob.summary()

history_iob = model_iob.fit(X_train_iob, y_train_iob, epochs=50, batch_size=32, validation_data=(X_test_iob, y_test_iob))

stock = "CASTROLIND.NS"
df_castrol = stock_data[stock]

close_prices_castrol = df_castrol['Close'].values.reshape(-1,1)

scaler_castrol = MinMaxScaler(feature_range=(0,1))
scaled_data_castrol = scaler_castrol.fit_transform(close_prices_castrol)

sequence_length = 60
X_castrol = []
y_castrol = []

for i in range(sequence_length, len(scaled_data_castrol)):
    X_castrol.append(scaled_data_castrol[i-sequence_length:i, 0])
    y_castrol.append(scaled_data_castrol[i, 0])

X_castrol, y_castrol = np.array(X_castrol), np.array(y_castrol)
X_castrol = np.reshape(X_castrol, (X_castrol.shape[0], X_castrol.shape[1], 1))

train_size = int(0.8 * X_castrol.shape[0])
X_train_castrol, X_test_castrol = X_castrol[:train_size], X_castrol[train_size:]
y_train_castrol, y_test_castrol = y_castrol[:train_size], y_castrol[train_size:]

print("Castrol - Training samples:", X_train_castrol.shape[0])
print("Castrol - Testing samples:", X_test_castrol.shape[0])

model_castrol = Sequential()

model_castrol.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_castrol.shape[1],1)))
model_castrol.add(Dropout(0.2))

model_castrol.add(LSTM(units=50, return_sequences=False))
model_castrol.add(Dropout(0.2))

model_castrol.add(Dense(1))

model_castrol.compile(optimizer='adam', loss='mean_squared_error')
model_castrol.summary()

history_castrol = model_castrol.fit(X_train_castrol, y_train_castrol, epochs=50, batch_size=32, validation_data=(X_test_castrol, y_test_castrol))

stock = "ASHOKLEY.NS"
df_ashok = stock_data[stock]

close_prices_ashok = df_ashok['Close'].values.reshape(-1,1)

scaler_ashok = MinMaxScaler(feature_range=(0,1))
scaled_data_ashok = scaler_ashok.fit_transform(close_prices_ashok)

sequence_length = 60
X_ashok = []
y_ashok = []

for i in range(sequence_length, len(scaled_data_ashok)):
    X_ashok.append(scaled_data_ashok[i-sequence_length:i, 0])
    y_ashok.append(scaled_data_ashok[i, 0])

X_ashok, y_ashok = np.array(X_ashok), np.array(y_ashok)
X_ashok = np.reshape(X_ashok, (X_ashok.shape[0], X_ashok.shape[1], 1))

train_size = int(0.8 * X_ashok.shape[0])
X_train_ashok, X_test_ashok = X_ashok[:train_size], X_ashok[train_size:]
y_train_ashok, y_test_ashok = y_ashok[:train_size], y_ashok[train_size:]

print("Ashok Leyland - Training samples:", X_train_ashok.shape[0])
print("Ashok Leyland - Testing samples:", X_test_ashok.shape[0])

model_ashok = Sequential()

model_ashok.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_ashok.shape[1],1)))
model_ashok.add(Dropout(0.2))

model_ashok.add(LSTM(units=50, return_sequences=False))
model_ashok.add(Dropout(0.2))

model_ashok.add(Dense(1))

model_ashok.compile(optimizer='adam', loss='mean_squared_error')
model_ashok.summary()

history_ashok = model_ashok.fit(X_train_ashok, y_train_ashok, epochs=50, batch_size=32, validation_data=(X_test_ashok, y_test_ashok))

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

import yfinance as yf

df_nmdc = yf.download("NMDC.NS", start="2018-01-01", end="2025-01-01")

close_prices_nmdc = df_nmdc['Close'].values.reshape(-1,1)
scaler_nmdc = MinMaxScaler(feature_range=(0,1))
scaled_data_nmdc = scaler_nmdc.fit_transform(close_prices_nmdc)

sequence_length = 60
X_nmdc, y_nmdc = [], []

for i in range(sequence_length, len(scaled_data_nmdc)):
    X_nmdc.append(scaled_data_nmdc[i-sequence_length:i, 0])
    y_nmdc.append(scaled_data_nmdc[i, 0])

X_nmdc, y_nmdc = np.array(X_nmdc), np.array(y_nmdc)
X_nmdc = np.reshape(X_nmdc, (X_nmdc.shape[0], X_nmdc.shape[1], 1))

train_size = int(0.8 * X_nmdc.shape[0])
X_train_nmdc, X_test_nmdc = X_nmdc[:train_size], X_nmdc[train_size:]
y_train_nmdc, y_test_nmdc = y_nmdc[:train_size], y_nmdc[train_size:]

model_nmdc = Sequential()
model_nmdc.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_nmdc.shape[1],1)))
model_nmdc.add(Dropout(0.2))
model_nmdc.add(LSTM(units=50, return_sequences=False))
model_nmdc.add(Dropout(0.2))
model_nmdc.add(Dense(1))
model_nmdc.compile(optimizer='adam', loss='mean_squared_error')

model_nmdc.fit(X_train_nmdc, y_train_nmdc, epochs=10, batch_size=32, validation_data=(X_test_nmdc, y_test_nmdc), verbose=1)

predicted_prices_nmdc = model_nmdc.predict(X_test_nmdc)
predicted_prices_nmdc = scaler_nmdc.inverse_transform(predicted_prices_nmdc.reshape(-1, 1))
real_prices_nmdc = scaler_nmdc.inverse_transform(y_test_nmdc.reshape(-1, 1))

plt.figure(figsize=(10,5))
plt.plot(real_prices_nmdc, color='blue', label='Actual NMDC Price')
plt.plot(predicted_prices_nmdc, color='red', label='Predicted NMDC Price')
plt.title('NMDC Stock Price Prediction')
plt.xlabel('Days')
plt.ylabel('Price (â‚¹)')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import yfinance as yf

df_nhpc = yf.download("NHPC.NS", start="2018-01-01", end="2025-01-01")

close_prices_nhpc = df_nhpc['Close'].values.reshape(-1,1)
scaler_nhpc = MinMaxScaler(feature_range=(0,1))
scaled_data_nhpc = scaler_nhpc.fit_transform(close_prices_nhpc)

sequence_length = 60
X_nhpc, y_nhpc = [], []

for i in range(sequence_length, len(scaled_data_nhpc)):
    X_nhpc.append(scaled_data_nhpc[i-sequence_length:i, 0])
    y_nhpc.append(scaled_data_nhpc[i, 0])

X_nhpc, y_nhpc = np.array(X_nhpc), np.array(y_nhpc)
X_nhpc = np.reshape(X_nhpc, (X_nhpc.shape[0], X_nhpc.shape[1], 1))

train_size = int(0.8 * X_nhpc.shape[0])
X_train_nhpc, X_test_nhpc = X_nhpc[:train_size], X_nhpc[train_size:]
y_train_nhpc, y_test_nhpc = y_nhpc[:train_size], y_nhpc[train_size:]

model_nhpc = Sequential()
model_nhpc.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_nhpc.shape[1],1)))
model_nhpc.add(Dropout(0.2))
model_nhpc.add(LSTM(units=50, return_sequences=False))
model_nhpc.add(Dropout(0.2))
model_nhpc.add(Dense(1))
model_nhpc.compile(optimizer='adam', loss='mean_squared_error')

model_nhpc.fit(X_train_nhpc, y_train_nhpc, epochs=10, batch_size=32, validation_data=(X_test_nhpc, y_test_nhpc), verbose=1)

predicted_prices_nhpc = model_nhpc.predict(X_test_nhpc)
predicted_prices_nhpc = scaler_nhpc.inverse_transform(predicted_prices_nhpc.reshape(-1, 1))
real_prices_nhpc = scaler_nhpc.inverse_transform(y_test_nhpc.reshape(-1, 1))

plt.figure(figsize=(10,5))
plt.plot(real_prices_nhpc, color='blue', label='Actual NHPC Price')
plt.plot(predicted_prices_nhpc, color='red', label='Predicted NHPC Price')
plt.title('NHPC Stock Price Prediction')
plt.xlabel('Days')
plt.ylabel('Price (â‚¹)')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import yfinance as yf

df_iob = yf.download("IOB.NS", start="2018-01-01", end="2025-01-01")

close_prices_iob = df_iob['Close'].values.reshape(-1,1)
scaler_iob = MinMaxScaler(feature_range=(0,1))
scaled_data_iob = scaler_iob.fit_transform(close_prices_iob)

sequence_length = 60
X_iob, y_iob = [], []

for i in range(sequence_length, len(scaled_data_iob)):
    X_iob.append(scaled_data_iob[i-sequence_length:i, 0])
    y_iob.append(scaled_data_iob[i, 0])

X_iob, y_iob = np.array(X_iob), np.array(y_iob)
X_iob = np.reshape(X_iob, (X_iob.shape[0], X_iob.shape[1], 1))

train_size = int(0.8 * X_iob.shape[0])
X_train_iob, X_test_iob = X_iob[:train_size], X_iob[train_size:]
y_train_iob, y_test_iob = y_iob[:train_size], y_iob[train_size:]

model_iob = Sequential()
model_iob.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_iob.shape[1],1)))
model_iob.add(Dropout(0.2))
model_iob.add(LSTM(units=50, return_sequences=False))
model_iob.add(Dropout(0.2))
model_iob.add(Dense(1))
model_iob.compile(optimizer='adam', loss='mean_squared_error')

model_iob.fit(X_train_iob, y_train_iob, epochs=10, batch_size=32, validation_data=(X_test_iob, y_test_iob), verbose=1)

predicted_prices_iob = model_iob.predict(X_test_iob)
predicted_prices_iob = scaler_iob.inverse_transform(predicted_prices_iob.reshape(-1, 1))
real_prices_iob = scaler_iob.inverse_transform(y_test_iob.reshape(-1, 1))

plt.figure(figsize=(10,5))
plt.plot(real_prices_iob, color='blue', label='Actual IOB Price')
plt.plot(predicted_prices_iob, color='red', label='Predicted IOB Price')
plt.title('IOB Stock Price Prediction')
plt.xlabel('Days')
plt.ylabel('Price (â‚¹)')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import yfinance as yf

df_castrol = yf.download("CASTROLIND.NS", start="2018-01-01", end="2025-01-01")

close_prices_castrol = df_castrol['Close'].values.reshape(-1,1)
scaler_castrol = MinMaxScaler(feature_range=(0,1))
scaled_data_castrol = scaler_castrol.fit_transform(close_prices_castrol)

sequence_length = 60
X_castrol, y_castrol = [], []

for i in range(sequence_length, len(scaled_data_castrol)):
    X_castrol.append(scaled_data_castrol[i-sequence_length:i, 0])
    y_castrol.append(scaled_data_castrol[i, 0])

X_castrol, y_castrol = np.array(X_castrol), np.array(y_castrol)
X_castrol = np.reshape(X_castrol, (X_castrol.shape[0], X_castrol.shape[1], 1))

train_size = int(0.8 * X_castrol.shape[0])
X_train_castrol, X_test_castrol = X_castrol[:train_size], X_castrol[train_size:]
y_train_castrol, y_test_castrol = y_castrol[:train_size], y_castrol[train_size:]

model_castrol = Sequential()
model_castrol.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_castrol.shape[1],1)))
model_castrol.add(Dropout(0.2))
model_castrol.add(LSTM(units=50, return_sequences=False))
model_castrol.add(Dropout(0.2))
model_castrol.add(Dense(1))
model_castrol.compile(optimizer='adam', loss='mean_squared_error')

model_castrol.fit(X_train_castrol, y_train_castrol, epochs=10, batch_size=32, validation_data=(X_test_castrol, y_test_castrol), verbose=1)

predicted_prices_castrol = model_castrol.predict(X_test_castrol)
predicted_prices_castrol = scaler_castrol.inverse_transform(predicted_prices_castrol.reshape(-1, 1))
real_prices_castrol = scaler_castrol.inverse_transform(y_test_castrol.reshape(-1, 1))

plt.figure(figsize=(10,5))
plt.plot(real_prices_castrol, color='blue', label='Actual Castrol Price')
plt.plot(predicted_prices_castrol, color='red', label='Predicted Castrol Price')
plt.title('Castrol India Stock Price Prediction')
plt.xlabel('Days')
plt.ylabel('Price (â‚¹)')
plt.legend()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import yfinance as yf

df_ashok = yf.download("ASHOKLEY.NS", start="2018-01-01", end="2025-01-01")

close_prices_ashok = df_ashok['Close'].values.reshape(-1,1)
scaler_ashok = MinMaxScaler(feature_range=(0,1))
scaled_data_ashok = scaler_ashok.fit_transform(close_prices_ashok)

sequence_length = 60
X_ashok, y_ashok = [], []

for i in range(sequence_length, len(scaled_data_ashok)):
    X_ashok.append(scaled_data_ashok[i-sequence_length:i, 0])
    y_ashok.append(scaled_data_ashok[i, 0])

X_ashok, y_ashok = np.array(X_ashok), np.array(y_ashok)
X_ashok = np.reshape(X_ashok, (X_ashok.shape[0], X_ashok.shape[1], 1))

train_size = int(0.8 * X_ashok.shape[0])
X_train_ashok, X_test_ashok = X_ashok[:train_size], X_ashok[train_size:]
y_train_ashok, y_test_ashok = y_ashok[:train_size], y_ashok[train_size:]

model_ashok = Sequential()
model_ashok.add(LSTM(units=50, return_sequences=True, input_shape=(X_train_ashok.shape[1],1)))
model_ashok.add(Dropout(0.2))
model_ashok.add(LSTM(units=50, return_sequences=False))
model_ashok.add(Dropout(0.2))
model_ashok.add(Dense(1))
model_ashok.compile(optimizer='adam', loss='mean_squared_error')

model_ashok.fit(X_train_ashok, y_train_ashok, epochs=10, batch_size=32, validation_data=(X_test_ashok, y_test_ashok), verbose=1)

predicted_prices_ashok = model_ashok.predict(X_test_ashok)
predicted_prices_ashok = scaler_ashok.inverse_transform(predicted_prices_ashok.reshape(-1, 1))
real_prices_ashok = scaler_ashok.inverse_transform(y_test_ashok.reshape(-1, 1))

plt.figure(figsize=(10,5))
plt.plot(real_prices_ashok, color='blue', label='Actual Ashok Leyland Price')
plt.plot(predicted_prices_ashok, color='red', label='Predicted Ashok Leyland Price')
plt.title('Ashok Leyland Stock Price Prediction')
plt.xlabel('Days')
plt.ylabel('Price (â‚¹)')
plt.legend()
plt.show()

!pip install streamlit
!pip install pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import yfinance as yf
# from sklearn.preprocessing import MinMaxScaler
# from tensorflow.keras.models import load_model
# 
# st.title("Stock Price Predictor")
# 
# stock_options = ['NMDC.NS', 'NHPC.NS', 'IOB.NS', 'CASTROLIND.NS', 'ASHOKLEY.NS']
# stock_name = st.selectbox("Select a stock:", stock_options)
# 
# df = yf.download(stock_name, start="2018-01-01", end="2025-01-01")
# st.subheader(f"{stock_name} Closing Prices")
# st.line_chart(df['Close'])
# 
# st.write("Prediction will be shown below (after selecting stock and running model)")
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# import yfinance as yf
# from sklearn.preprocessing import MinMaxScaler
# from tensorflow.keras.models import Sequential, load_model
# from tensorflow.keras.layers import LSTM, Dense, Dropout
# import matplotlib.pyplot as plt
# 
# st.title("Stock Price Predictor AI")
# 
# stock_options = ['NMDC.NS', 'NHPC.NS', 'IOB.NS', 'CASTROLIND.NS', 'ASHOKLEY.NS']
# stock_name = st.selectbox("Select a stock:", stock_options)
# 
# df = yf.download(stock_name, start="2018-01-01", end="2025-01-01")
# st.subheader(f"{stock_name} Closing Prices")
# st.line_chart(df['Close'])
# 
# close_prices = df['Close'].values.reshape(-1,1)
# scaler = MinMaxScaler(feature_range=(0,1))
# scaled_data = scaler.fit_transform(close_prices)
# 
# sequence_length = 60
# X = []
# y = []
# for i in range(sequence_length, len(scaled_data)):
#     X.append(scaled_data[i-sequence_length:i, 0])
#     y.append(scaled_data[i, 0])
# 
# X, y = np.array(X), np.array(y)
# X = np.reshape(X, (X.shape[0], X.shape[1], 1))
# 
# train_size = int(0.8 * X.shape[0])
# X_train, X_test = X[:train_size], X[train_size:]
# y_train, y_test = y[:train_size], y[train_size:]
# 
# model = Sequential()
# model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1],1)))
# model.add(Dropout(0.2))
# model.add(LSTM(50, return_sequences=False))
# model.add(Dropout(0.2))
# model.add(Dense(1))
# model.compile(optimizer='adam', loss='mean_squared_error')
# 
# model.fit(X_train, y_train, epochs=10, batch_size=32, verbose=0)
# 
# predicted_prices = model.predict(X_test)
# predicted_prices = scaler.inverse_transform(predicted_prices.reshape(-1,1))
# real_prices = scaler.inverse_transform(y_test.reshape(-1,1))
# 
# st.subheader(f"{stock_name} Prediction vs Actual")
# fig, ax = plt.subplots(figsize=(10,5))
# ax.plot(real_prices, color='blue', label='Actual Price')
# ax.plot(predicted_prices, color='red', label='Predicted Price')
# ax.set_xlabel("Days")
# ax.set_ylabel("Price (â‚¹)")
# ax.legend()
# st.pyplot(fig)
#

!streamlit run app.py

# app.py
import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import load_model
import matplotlib.pyplot as plt

st.title("Stock Price Predictor AI")

# Select stock
stock_options = ['NMDC.NS', 'NHPC.NS', 'IOB.NS', 'CASTROLIND.NS', 'ASHOKLEY.NS']
stock_name = st.selectbox("Select a stock:", stock_options)

# Load pre-trained model based on selected stock
if stock_name == 'NMDC.NS':
    model = load_model("model_nmdc.h5")
elif stock_name == 'NHPC.NS':
    model = load_model("model_nhpc.h5")
elif stock_name == 'IOB.NS':
    model = load_model("model_iob.h5")
elif stock_name == 'CASTROLIND.NS':
    model = load_model("model_castrol.h5")
elif stock_name == 'ASHOKLEY.NS':
    model = load_model("model_ashok.h5")

# Fetch data
df = yf.download(stock_name, start="2018-01-01", end="2025-01-01")
st.subheader(f"{stock_name} Closing Prices")
st.line_chart(df['Close'])

# Prepare data
close_prices = df['Close'].values.reshape(-1,1)
scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(close_prices)

sequence_length = 60
X = []
y = []
for i in range(sequence_length, len(scaled_data)):
    X.append(scaled_data[i-sequence_length:i,0])
    y.append(scaled_data[i,0])
X, y = np.array(X), np.array(y)
X = np.reshape(X, (X.shape[0], X.shape[1], 1))

# Split test
train_size = int(0.8 * X.shape[0])
X_test = X[train_size:]
y_test = y[train_size:]

# Predict
predicted_prices = model.predict(X_test)
predicted_prices = scaler.inverse_transform(predicted_prices.reshape(-1,1))
real_prices = scaler.inverse_transform(y_test.reshape(-1,1))

# Plot Actual vs Predicted
st.subheader(f"{stock_name} Prediction vs Actual")
fig, ax = plt.subplots(figsize=(10,5))
ax.plot(real_prices, color='blue', label='Actual Price')
ax.plot(predicted_prices, color='red', label='Predicted Price')
ax.set_xlabel("Days")
ax.set_ylabel("Price (â‚¹)")
ax.legend()
st.pyplot(fig)

!streamlit run app.py

# ----------------- NMDC Next Day Prediction -----------------
import numpy as np
from tensorflow.keras.models import load_model
from sklearn.preprocessing import MinMaxScaler
import yfinance as yf

model = load_model("model_nmdc.h5")

df = yf.download("NMDC.NS", start="2025-01-01")  # From Jan 2025 to today
close_prices = df['Close'].values.reshape(-1,1)

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(close_prices)

last_60_days = scaled_data[-60:]
X_input = np.reshape(last_60_days, (1, last_60_days.shape[0], 1))

predicted_scaled = model.predict(X_input)
predicted_price = scaler.inverse_transform(predicted_scaled.reshape(-1,1))[0][0]

last_price = close_prices[-1][0]

print(f"Last closing price (most recent): â‚¹{last_price:.2f}")
print(f"Predicted closing price for next market day: â‚¹{predicted_price:.2f}")

if predicted_price > last_price:
    print("Prediction: Stock likely to go UP tomorrow ðŸ“ˆ")
else:
    print("Prediction: Stock likely to go DOWN tomorrow ðŸ“‰")

# ----------------- Next Day Prediction for 5 Stocks -----------------
import numpy as np
import yfinance as yf
from tensorflow.keras.models import load_model
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

# List of 5 stocks and their trained models
stocks = {
    'NMDC.NS': 'model_nmdc.h5',
    'NHPC.NS': 'model_nhpc.h5',
    'IOB.NS': 'model_iob.h5',
    'CASTROLIND.NS': 'model_castrol.h5',
    'ASHOKLEY.NS': 'model_ashok.h5'
}

last_prices = []
predicted_prices = []

for stock, model_file in stocks.items():
    # Load trained model
    model = load_model(model_file)

    # Fetch latest stock data
    df = yf.download(stock, start="2025-01-01")
    close_prices = df['Close'].values.reshape(-1,1)

    # Scale data
    scaler = MinMaxScaler(feature_range=(0,1))
    scaled_data = scaler.fit_transform(close_prices)

    # Prepare last 60 days for prediction
    last_60_days = scaled_data[-60:]
    X_input = np.reshape(last_60_days, (1, last_60_days.shape[0], 1))

    # Predict next day price
    predicted_scaled = model.predict(X_input)
    predicted_price = scaler.inverse_transform(predicted_scaled.reshape(-1,1))[0][0]

    # Store last and predicted prices
    last_prices.append(close_prices[-1][0])
    predicted_prices.append(predicted_price)

    # Print prediction
    print(f"{stock}: Last Close = â‚¹{close_prices[-1][0]:.2f}, Predicted Next = â‚¹{predicted_price:.2f}",
          "ðŸ“ˆ" if predicted_price > close_prices[-1][0] else "ðŸ“‰")

# === Ensure models exist, train missing ones, then predict next 5 days for all 5 stocks ===
import os
import numpy as np
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential, load_model
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Stocks and model filenames
stocks = {
    'NMDC.NS': 'model_nmdc.h5',
    'NHPC.NS': 'model_nhpc.h5',
    'IOB.NS': 'model_iob.h5',
    'CASTROLIND.NS': 'model_castrol.h5',
    'ASHOKLEY.NS': 'model_ashok.h5'
}

def prepare_data_for_stock(stock_symbol, start_date="2018-01-01"):
    df = yf.download(stock_symbol, start=start_date)
    close = df['Close'].values.reshape(-1,1)
    scaler = MinMaxScaler(feature_range=(0,1))
    scaled = scaler.fit_transform(close)
    # build sequences
    seq_len = 60
    X, y = [], []
    for i in range(seq_len, len(scaled)):
        X.append(scaled[i-seq_len:i, 0])
        y.append(scaled[i, 0])
    X = np.array(X); y = np.array(y)
    X = X.reshape((X.shape[0], X.shape[1], 1))
    # split train/test
    train_size = int(0.8 * X.shape[0])
    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]
    return df, scaler, X_train, X_test, y_train, y_test

def build_and_train_model(X_train, y_train, X_test, y_test, epochs=10):
    model = Sequential()
    model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1],1)))
    model.add(Dropout(0.2))
    model.add(LSTM(units=50, return_sequences=False))
    model.add(Dropout(0.2))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mean_squared_error')
    model.fit(X_train, y_train, epochs=epochs, batch_size=32, validation_data=(X_test, y_test), verbose=1)
    return model

# 1) Ensure models exist (train & save missing ones)
for stock_sym, model_file in stocks.items():
    if os.path.exists(model_file):
        print(f"âœ… Found existing model file: {model_file}")
    else:
        print(f"âš ï¸ Model file not found for {stock_sym}. Will train & save -> {model_file}")
        # prepare data
        df, scaler, X_train, X_test, y_train, y_test = prepare_data_for_stock(stock_sym, start_date="2018-01-01")
        # If dataset too small, skip
        if X_train.shape[0] < 10:
            raise RuntimeError(f"Not enough data to train for {stock_sym}. Rows: {len(df)}")
        # train model (10 epochs quick training)
        model_tr = build_and_train_model(X_train, y_train, X_test, y_test, epochs=10)
        # save
        model_tr.save(model_file)
        print(f"âž¡ï¸ Saved model for {stock_sym} as {model_file}")

# 2) Now all models should exist â€” run next-5-days prediction for all stocks
days_to_predict = 5
predictions_all = {}

for stock_sym, model_file in stocks.items():
    print(f"\nðŸ“Š Predicting next {days_to_predict} days for {stock_sym} ...")
    # load model
    model = load_model(model_file)
    # fetch latest data
    df = yf.download(stock_sym, start="2018-01-01")
    close_prices = df['Close'].values.reshape(-1,1)
    if len(close_prices) < 60:
        raise RuntimeError(f"Not enough historical data for {stock_sym} to predict (need >=60 days). Got {len(close_prices)}")
    # scale
    scaler = MinMaxScaler(feature_range=(0,1))
    scaled = scaler.fit_transform(close_prices)
    # create list of last 60 scaled points (as floats)
    last_60 = scaled[-60:].flatten().tolist()
    preds = []
    for d in range(days_to_predict):
        X_in = np.array(last_60[-60:]).reshape(1,60,1)
        pred_scaled = model.predict(X_in, verbose=0)
        pred_price = scaler.inverse_transform(pred_scaled.reshape(-1,1))[0][0]
        preds.append(float(pred_price))
        # append scaled prediction back to sequence (use scaled value)
        last_60.append(float(pred_scaled[0][0]))
    predictions_all[stock_sym] = {
        "last_close": float(close_prices[-1][0]),
        "predicted": preds
    }
    # Print
    print(f"Last Close = â‚¹{predictions_all[stock_sym]['last_close']:.2f}")
    for i,p in enumerate(preds,1):
        print(f" Day {i}: â‚¹{p:.2f} {'ðŸ“ˆ' if p>predictions_all[stock_sym]['last_close'] else 'ðŸ“‰'}")

# 3) Plot summary: each stock line for 5 days + marker for last close
plt.figure(figsize=(11,6))
for stock_sym, vals in predictions_all.items():
    last = vals["last_close"]
    preds = vals["predicted"]
    x = np.arange(0, len(preds)+1)  # 0 is last close, 1..5 next days
    y = [last] + preds
    plt.plot(x, y, marker='o', label=stock_sym)
# formatting
plt.xticks(np.arange(0, days_to_predict+1), ['Last'] + [f'Day{i}' for i in range(1, days_to_predict+1)])
plt.xlabel("Days")
plt.ylabel("Price (â‚¹)")
plt.title(f"Next {days_to_predict} Days Predicted Prices (per stock)")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

stock = "NMDC.NS"
df = yf.download(stock, start="2020-01-01")
data = df["Close"].values.reshape(-1, 1)

# Scale data
scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(data)

# Prepare data for LSTM
X, y = [], []
for i in range(60, len(scaled_data)):
    X.append(scaled_data[i-60:i, 0])
    y.append(scaled_data[i, 0])
X, y = np.array(X), np.array(y)
X = X.reshape(X.shape[0], X.shape[1], 1)

# Build and train model
model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(X.shape[1],1)),
    LSTM(50),
    Dense(1)
])
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X, y, epochs=5, batch_size=32, verbose=0)

# Save model
model.save("model_nmdc.h5")

# Predict next day
last_60 = scaled_data[-60:].reshape(1, 60, 1)
pred_scaled = model.predict(last_60)
predicted_price = scaler.inverse_transform(pred_scaled)[0][0]
today_close = data[-1][0]

print(f"ðŸ“ˆ NMDC Ltd.")
print(f"Today's Close (23 Oct 2025): â‚¹{today_close:.2f}")
print(f"Predicted Close (24 Oct 2025): â‚¹{predicted_price:.2f}")

plt.plot([1,2], [today_close, predicted_price], marker='o')
plt.xticks([1,2], ['Today', 'Tomorrow'])
plt.title("NMDC Ltd. â€“ Price Prediction")
plt.grid(True)
plt.show()

import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

stock = "NHPC.NS"
df = yf.download(stock, start="2020-01-01")
data = df["Close"].values.reshape(-1, 1)

scaler = MinMaxScaler(feature_range=(0,1))
scaled_data = scaler.fit_transform(data)

X, y = [], []
for i in range(60, len(scaled_data)):
    X.append(scaled_data[i-60:i, 0])
    y.append(scaled_data[i, 0])
X, y = np.array(X), np.array(y)
X = X.reshape(X.shape[0], X.shape[1], 1)

model = Sequential([
    LSTM(50, return_sequences=True, input_shape=(X.shape[1],1)),
    LSTM(50),
    Dense(1)
])
model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(X, y, epochs=5, batch_size=32, verbose=0)

model.save("model_nhpc.h5")

last_60 = scaled_data[-60:].reshape(1, 60, 1)
pred_scaled = model.predict(last_60)
predicted_price = scaler.inverse_transform(pred_scaled)[0][0]
today_close = data[-1][0]

print(f"ðŸ“ˆ NHPC Ltd.")
print(f"Today's Close (23 Oct 2025): â‚¹{today_close:.2f}")
print(f"Predicted Close (24 Oct 2025): â‚¹{predicted_price:.2f}")

plt.plot([1,2], [today_close, predicted_price], marker='o')
plt.xticks([1,2], ['Today', 'Tomorrow'])
plt.title("NHPC Ltd. â€“ Price Prediction")
plt.grid(True)
plt.show()

